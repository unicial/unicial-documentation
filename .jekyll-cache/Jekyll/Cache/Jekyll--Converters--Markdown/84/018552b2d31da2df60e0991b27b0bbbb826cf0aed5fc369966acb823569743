I"É><h2 id="the-development-tools">The development tools</h2>

<p>At a very high level, the <strong>Decentraland Software Development Kit</strong> (SDK) allows you to do the following:</p>

<ul>
  <li>Generate a default <em>project</em> containing a Decentraland scene, including all the assets needed to render and run your content.</li>
  <li>Build, test, and preview the content of your scene locally in your web browser - completely offline, and without having to make any Ethereum transactions or own LAND.</li>
  <li>Write TypeScript code using the Decentraland API to add interactive and dynamic behavior to the scene.</li>
  <li>Upload the content of your scene to the content server.</li>
  <li>Link your LAND tokens to the URL of the content you have uploaded.</li>
</ul>

<p>Our SDK includes the following components:</p>

<!--
- **The Decentraland Editor**: Use it to create and preview Decentraland scenes. You don't need to download any software to your machine, the editor runs entirely on your browser.
-->

<ul>
  <li><strong>The Decentraland CLI</strong> (Command Line Interface): Use it to <a href="/development-guide/coding-scenes/">generate</a> new Decentraland scenes locally on your own machine, preview them and upload them to the content server.</li>
  <li>
    <p><strong>The Decentraland ECS</strong>: A TypeScript package containing the library of helper methods that allows you to create interactive experiences. Use it to create and manipulate objects in the scene and also to facilitate in-world transactions between players or other applications. ( <a href="https://github.com/decentraland/ecs-reference/blob/master/docs-latest/decentraland-ecs.md">latest ECS reference</a>)</p>
  </li>
  <li><strong>Scene examples</strong>: Take inspiration and coding best practices from the <a href="https://github.com/decentraland-scenes/Awesome-Repository#examples">scene examples</a>.</li>
</ul>

<h2 id="requirements">Requirements</h2>

<p>To develop a scene locally, you don‚Äôt need to own LAND tokens. Developing and testing a scene can be done completely offline, without the need to deploy a scene to the Ethereum network (the system Decentraland uses to establish ownership of LAND), or the content server.</p>

<p>You must have the following:</p>

<ul>
  <li>
    <p><strong>npm</strong> (Node package manager): Used in the terminal to handle scene dependencies, required to install the Decentraland CLI. <a href="nodejs.org">Download link</a></p>
  </li>
  <li>
    <p><strong>The Decentraland CLI</strong>: Used to build, preview and upload scenes. See <a href="/development-guide/installation-guide/">Installation guide</a></p>
  </li>
  <li>
    <p><strong>A source code editor</strong>: Helps you create scenes a lot faster and with less errors. A source code editor marks syntax errors, autocompletes while you write and even shows you smart suggestions that depend on the context that you‚Äôre in. You can also click on an object in the code to see the full definition of its class and what attributes it supports. We recommend <a href="https://code.visualstudio.com/">Visual Studio Code</a> or <a href="https://atom.io/">Atom</a>.</p>
  </li>
</ul>

<h2 id="supported-languages-and-syntax">Supported languages and syntax</h2>

<h4 id="typescript-recommended">TypeScript (recommended)</h4>

<p>We use <a href="https://www.typescriptlang.org/docs/handbook/jsx.html">TypeScript (.ts)</a>
to create our scenes.</p>

<p>TypeScript is a superset of JavaScript, so if you‚Äôre familiar with JavaScript you‚Äôll find it‚Äôs almost the same, but TypeScript allows you to employ object-oriented programming and type declarations. Features like autocomplete and type-checking speed up development times and allow for the creation of a more solid codebase. These features are all key components to a positive developer experience.</p>

<h4 id="other-languages">Other languages</h4>

<p>You can use another tool or language instead of TypeScript and compile it into JavaScript, as long as your compiled scripts are contained within a single JavaScript file named <em>game.js</em>. All provided type declarations are made in TypeScript, and other languages and transpilers are not officially supported.</p>

<h2 id="scenes">Scenes</h2>

<p>The content you deploy to your LAND is called a <strong>scene</strong>. A scene is an interactive program that renders content, this could be a game, an interactive experience, an art gallery, whatever you want!</p>

<p>Scenes are deployed to virtual LAND in Decentraland. LAND is a scarce and non-fungible asset maintained in an Ethereum smart contract. Deploy to a single <strong>parcel</strong>, a 16 meter by 16 meter piece of LAND, or to an <strong>estate</strong>, comprised of multiple adjacent parcels.</p>

<p>We are developing the web client that will allow players to explore Decentraland. All of the content you upload to your LAND will be rendered and viewable through this client. We have included a preview tool in the SDK so that you can preview, test, and interact with your content in the meantime.</p>

<h2 id="entities-and-components">Entities and Components</h2>

<p>Three dimensional scenes in Decentraland are based on an <a href="https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system">Entity-Component-System</a> architecture, where everything in a scene is an <em>entity</em>, and each entity can include <em>components</em> that determine its characteristics.</p>

<p><img src="/images/media/ecs-components.png" alt="nested entities" width="400" /></p>

<p>Entities are nested inside other entities to form a tree structure. If you‚Äôre familiar with web development, you might find it useful to think of entities as elements in a DOM tree and of components as the attributes of each of these elements.</p>

<p><img src="/images/media/ecs-nested-entities.png" alt="nested entities" width="400" /></p>

<p>See <a href="/development-guide/entities-components/">Entities and components</a> for an in-depth look of both these concepts and how they‚Äôre used by Decentraland scenes.</p>

<h2 id="the-game-loop">The game loop</h2>

<p>The <a href="http://gameprogrammingpatterns.com/game-loop.html">game loop</a> is the backbone of a Decentraland scene‚Äôs code. It cycles through part of the code at a regular interval and does the following:</p>

<ul>
  <li>Listen for player input</li>
  <li>Update the scene</li>
  <li>Re-render the scene</li>
</ul>

<p>In most traditional software programs, all events are triggered directly by player actions. Nothing in the program‚Äôs state will change until the player clicks on a button, opens a menu, etc.</p>

<p>But interactive environments and games are different from that. Not all changes to the scene are necessarily caused by a player‚Äôs actions. Your scene could have animated objects that move on their own or even non-player characters that have their own AI. Some player actions might also take multiple frames to be completed, for example if the opening of a door needs to take a whole second, the door‚Äôs rotation must be incrementally updated about 30 times as it moves.</p>

<p>We call each iteration over the loop a <em>frame</em>. Decentraland scenes are rendered at 30 frames per second whenever possible. If a frame takes more time than that to be rendered, then less frames will be processed.</p>

<p>In each frame, the scene is updated; then the scene is re-rendered, based on the updated values.</p>

<p>In Decentraland scenes, there is no explicitly declared game loop, but rather the <code class="language-plaintext highlighter-rouge">update()</code> functions on the <a href="/development-guide/systems/">Systems</a> of the scene make up the game loop.</p>

<p>The compiling and rendering of the scene is carried out in the backend, you don‚Äôt need to handle that while developing your scene.</p>

<h2 id="systems">Systems</h2>

<p>Entities and components are places to store information about the objects in a scene. <em>Systems</em> hold functions that change the information that‚Äôs stored in components.</p>

<p><em>Systems</em> are what make a static scene dynamic, allowing things to change over time or in response to player interaction.</p>

<p>Each System has an <code class="language-plaintext highlighter-rouge">update()</code> method that‚Äôs executed on every frame of the game loop, following the <a href="http://gameprogrammingpatterns.com/update-method.html"><em>update pattern</em></a>.</p>

<p>See <a href="/development-guide/systems/">Systems</a> for more details about how systems are used in a scene.</p>

<h2 id="component-groups">Component groups</h2>

<p><a href="/development-guide/component-groups/">Component groups</a> keep track of all entities in the scene that have certain components in them. Once a component group is created, it automatically keeps its list up to date with each new entity or component that is added or removed.</p>

<p>If you attempt to update all the entities in the scene on every frame, that could have a significant cost in performance. By referring only to the entities in a component group, you ensure you‚Äôre only dealing with those that are relevant.</p>

<p>Component groups can be referenced by the functions in a <a href="/development-guide/systems/">system</a>. Typically an <code class="language-plaintext highlighter-rouge">update()</code> function will loop over the entities in the component group, performing the same actions on each.</p>

<h2 id="putting-it-all-together">Putting it all together</h2>

<p>The <em>engine</em> is what sits in between <em>entities</em>, <em>components</em> and <em>component groups</em> on one hand and <em>systems</em> on the other. It calls system‚Äôs functions, updates groups when entities are added, etc.</p>

<p><img src="/images/media/ecs-big-picture.png" alt="" /></p>

<p>All of the values stored in the components in the scene represent the scene‚Äôs state at that point in time. With every frame of the game loop, the engine runs the <code class="language-plaintext highlighter-rouge">update()</code> function of each of the systems to update the values stored in the components.</p>

<p>After all the systems run, the components on each entity will have new values. When the engine renders the scene, it will use these new updated values and players will see the entities change to match their new states.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create a group to track all entities with a Transform component</span>
<span class="kd">const</span> <span class="nx">myGroup</span> <span class="o">=</span> <span class="nx">engine</span><span class="p">.</span><span class="nx">getComponentGroup</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>

<span class="c1">// Define a System</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">RotatorSystem</span> <span class="k">implements</span> <span class="nx">ISystem</span> <span class="p">{</span>
  <span class="c1">// The update function runs on every frame of the game loop</span>
  <span class="nx">update</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// The function iterates over all the entities in myGroup</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">entity</span> <span class="k">of</span> <span class="nx">myGroup</span><span class="p">.</span><span class="nx">entities</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">entity</span><span class="p">.</span><span class="nx">getComponent</span><span class="p">(</span><span class="nx">Transform</span><span class="p">)</span>
      <span class="nx">transform</span><span class="p">.</span><span class="nx">rotate</span><span class="p">(</span><span class="nx">Vector3</span><span class="p">.</span><span class="nx">Left</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Add the system to the engine</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addSystem</span><span class="p">(</span><span class="k">new</span> <span class="nx">RotatorSystem</span><span class="p">())</span>

<span class="c1">// Create an entity</span>
<span class="kd">const</span> <span class="nx">cube</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Entity</span><span class="p">()</span>

<span class="c1">// Give the entity a transform component</span>
<span class="nx">cube</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span>
  <span class="k">new</span> <span class="nx">Transform</span><span class="p">({</span>
    <span class="na">position</span><span class="p">:</span> <span class="k">new</span> <span class="nx">Vector3</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
  <span class="p">})</span>
<span class="p">)</span>

<span class="c1">// Give the entity a box shape</span>
<span class="nx">cube</span><span class="p">.</span><span class="nx">addComponent</span><span class="p">(</span><span class="k">new</span> <span class="nx">BoxShape</span><span class="p">())</span>

<span class="c1">// Add the entity to the engine</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">addEntity</span><span class="p">(</span><span class="nx">cube</span><span class="p">)</span>
</code></pre></div></div>

<p>In the example above, a <code class="language-plaintext highlighter-rouge">cube</code> entity and a <code class="language-plaintext highlighter-rouge">RotatorSystem</code> system are added to the engine. The <code class="language-plaintext highlighter-rouge">cube</code> entity has a <code class="language-plaintext highlighter-rouge">Transform</code>, and a <code class="language-plaintext highlighter-rouge">BoxShape</code> component. In every frame of the game loop, the <code class="language-plaintext highlighter-rouge">update()</code> function of <code class="language-plaintext highlighter-rouge">RotationSystem</code> is called, and it changes the rotation values in the <code class="language-plaintext highlighter-rouge">Transform</code> component of the <code class="language-plaintext highlighter-rouge">cube</code> entity.</p>

<p>Note that most of the code above is executed just once, when loading the scene. The exception is the <code class="language-plaintext highlighter-rouge">update()</code> method of the system, which is called on every frame of the game loop.</p>

<h2 id="scene-decoupling">Scene Decoupling</h2>

<p>Your scenes don‚Äôt run in the same context as the engine
(a.k.a. the main thread). We created the SDK in a way that is
entirely decoupled from the rendering engine. We designed it to be like this for both safety and performance reasons.</p>

<p>Because of this decoupling, your scene‚Äôs code doesn‚Äôt have access to the DOM or the <code class="language-plaintext highlighter-rouge">window</code> object, so you can‚Äôt access data like the player‚Äôs browser or geographical location.</p>

<p>The decoupling works by using RPC protocol, this protocol assigns a small part of the client to only render the scene and control events.</p>

<p>We have also abstracted the communication protocol. This allows us to run the scenes locally in a WebWorker.</p>

<p>We don‚Äôt want developers to intervene with the internals of the engine or even need to know what lies inside the engine. We need to ensure a consistent experience for players throughout the Decentraland map, and mistakes are more likely to happen at that ‚Äúlow‚Äù level.</p>
:ET